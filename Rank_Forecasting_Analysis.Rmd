---
title: "Rank Forecasting"
author: "Taylan Kabbani"
date: "January 19, 2021"
output: pdf_document
---
# Required Packages and data import
```{r, warning = FALSE, message = FALSE}
library(readxl)
library(tidyverse)
library(ggfortify)
library(ggplot2)
library(tsbox)
library(imputeTS)
library(cowplot)
library(forecast)

SpotifyData <- read_excel("Data/SpotifyData_full.xlsx")
```


```{r, warning = FALSE, message = FALSE}
# Extracting specific song streams and return it as ts object
FindSong <- function(SongName, ArtistName){
  song_Rank <- as.data.frame(SpotifyData %>% filter(song == SongName & Artist == ArtistName) %>% select(Date,Rank))

  # ts_ts will convert df to time series
  song_Rank <- ts_ts(ts_c(song_Rank))
  song_Rank
}
```


# SOng2
## Preliminary (exploratory) analysis.
```{r, warning = FALSE, message = FALSE}
song2 <- FindSong('Ölüme İnat', 'Hidra')

# song2_plt1 <- autoplot(song2) +
#   ggtitle('Song: Seni Dert Etmeler') +
#   xlab("Weeks") +
#   ylab("# Streams")

# Imputation by Interpolation method is used to fill missing values. This method is appropriate for time series with strong trend. [ref1]

#ggplot_na_imputations(song2, na_interpolation(song2))

#song2 <- na_interpolation(song2)
song2
```

```{r}
# From the ACF plot we conclude that the data is non stationary having a strong trend and cyclical components and no seasonality
ggAcf(song2)
```

```{r}
# The time series we are dealing with that have been collected at regular intervals (weekly) that are less than the one year (42 weeks), therefore normal decomposition method will not be useful. 
#It is possible to use a linear regression model to decompose a time series into trend and seasonal components, and then some smoothness assumptions on the seasonal component allow a decomposition with fewer than two full years of data. 

# Approximating the seasonal pattern using Fourier terms with a few parameters.
decompose_song2 <- tslm(song2 ~ trend + fourier(song2, 1))

# Trend component as moving average function
trend <- coef(decompose_song2)['(Intercept)'] +coef(decompose_song2)['trend']*seq_along(song2)

e <- residuals(decompose_song2)

# Additive model is used to decompose the time series data
seasonality <- song2 - trend - e

components <- cbind(
  data = song2,
  trend = trend,
  seasonal = seasonality,
  residuals =e
  )

autoplot(components,facet=TRUE)

```
```{r}

train <- subset(song2, end = length(song2)-1)

test <- subset(song2, start= length(song2))
```
# To predict the rank of a song in the top 200 top songs, I use a simple forecasting methods:

#Method 1: Average method
```{r}
fit.avg <- meanf(train, h=1)


checkresiduals(fit.avg)

round(accuracy(fit.avg, test),2)

autoplot(fit.avg) +
  autolayer(fitted(fit.avg), series="Average method", PI=FALSE) +
  autolayer(song2, series="Data", PI=FALSE) +
  ggtitle("Forecasts from Average method") + xlab("Weeks") +
  ylab("Rank") +
  guides(colour=guide_legend(title="Forecast"))
```

# Random Walk(Naive forecast)
```{r}
fit.rwk <- rwf(train, 1)

checkresiduals(fit.rwk)

round(accuracy(fit.rwk, test),2)

autoplot(fit.rwk) +
  autolayer(fitted(fit.rwk), series="Random Walk", PI=FALSE) +
  autolayer(song2, series="Data", PI=FALSE) +
  ggtitle("Forecasts from Random Walk") + xlab("Weeks") +
  ylab("Rank") +
  guides(colour=guide_legend(title="Forecast"))
```
# But its very clear that the data have an upward/down trend and a decision must be made to modify the naive model! Our technique can be adjusted to take trend into consideration by adding the difference between this period and the last period.
```{r}
fit.rwkd <- rwf(train, 1,lambda = 0)

checkresiduals(fit.rwkd)

round(accuracy(fit.rwkd, test),2)

autoplot(fit.rwkd) +
  autolayer(fitted(fit.rwkd), series="Random Walk", PI=FALSE) +
  autolayer(song2, series="Data", PI=FALSE) +
  ggtitle("Forecasts from Random Walk") + xlab("Weeks") +
  ylab("Rank") +
  guides(colour=guide_legend(title="Forecast"))
```

```{r}
fit.holt <- holt(train, h=1)
checkresiduals(fit.holt)

round(accuracy(fit.holt, test),2)

autoplot(fit.holt) +
  autolayer(fitted(fit.holt), series="holt", PI=FALSE) +
  autolayer(song2, series="Data", PI=FALSE) +
  ggtitle("Forecasts from Random Walk") + xlab("Weeks") +
  ylab("Rank") +
  guides(colour=guide_legend(title="Forecast"))
```
